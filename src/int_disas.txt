
int_object.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <new_fbgc_int_object>:
#include "fbgc.h"


struct
fbgc_object * new_fbgc_int_object(int int_content){
   0:	f3 0f 1e fa          	endbr64 
   4:	53                   	push   rbx
   5:	89 fb                	mov    ebx,edi
	struct fbgc_int_object *into =  (struct fbgc_int_object*) fbgc_malloc(sizeof_fbgc_int_object());
   7:	bf 0d 00 00 00       	mov    edi,0xd
   c:	e8 00 00 00 00       	call   11 <new_fbgc_int_object+0x11>	d: R_X86_64_PLT32	fbgc_malloc-0x4
	into->base.type = INT;
  11:	c6 00 03             	mov    BYTE PTR [rax],0x3
	//into->base.next = NULL;
	into->content = int_content; 
  14:	89 58 09             	mov    DWORD PTR [rax+0x9],ebx
	return (struct fbgc_object*) into;
}
  17:	5b                   	pop    rbx
  18:	c3                   	ret    

0000000000000019 <derive_from_new_int_object>:

struct
fbgc_object * derive_from_new_int_object(fbgc_token type, int int_content){
  19:	f3 0f 1e fa          	endbr64 
  1d:	55                   	push   rbp
  1e:	89 fd                	mov    ebp,edi
	struct fbgc_int_object *into =  (struct fbgc_int_object*) fbgc_malloc(sizeof_fbgc_int_object());
  20:	bf 0d 00 00 00       	mov    edi,0xd
fbgc_object * derive_from_new_int_object(fbgc_token type, int int_content){
  25:	53                   	push   rbx
  26:	89 f3                	mov    ebx,esi
  28:	50                   	push   rax
	struct fbgc_int_object *into =  (struct fbgc_int_object*) fbgc_malloc(sizeof_fbgc_int_object());
  29:	e8 00 00 00 00       	call   2e <derive_from_new_int_object+0x15>	2a: R_X86_64_PLT32	fbgc_malloc-0x4
	into->base.type = type;
  2e:	40 88 28             	mov    BYTE PTR [rax],bpl
	into->content = int_content; 
  31:	89 58 09             	mov    DWORD PTR [rax+0x9],ebx
	return (struct fbgc_object*) into;
}
  34:	5a                   	pop    rdx
  35:	5b                   	pop    rbx
  36:	5d                   	pop    rbp
  37:	c3                   	ret    

0000000000000038 <new_fbgc_int_object_from_str>:


struct
fbgc_object * new_fbgc_int_object_from_str(const char * int_str){
  38:	f3 0f 1e fa          	endbr64 
  3c:	50                   	push   rax

	return new_fbgc_int_object(strtol(int_str,NULL,10));
  3d:	ba 0a 00 00 00       	mov    edx,0xa
  42:	31 f6                	xor    esi,esi
  44:	e8 00 00 00 00       	call   49 <new_fbgc_int_object_from_str+0x11>	45: R_X86_64_PLT32	strtol-0x4
}
  49:	5a                   	pop    rdx
	return new_fbgc_int_object(strtol(int_str,NULL,10));
  4a:	48 89 c7             	mov    rdi,rax
  4d:	eb b1                	jmp    0 <new_fbgc_int_object>

000000000000004f <new_fbgc_int_object_from_substr>:


struct fbgc_object * new_fbgc_int_object_from_substr(const char * int_str_begin,const char * int_str_end,uint8_t base){
  4f:	f3 0f 1e fa          	endbr64 
  53:	50                   	push   rax
	//now we don't wanna check inf or overflow issue but later we are going to check them
	return new_fbgc_int_object(strtol(int_str_begin, NULL,base));
  54:	0f b6 d2             	movzx  edx,dl
  57:	31 f6                	xor    esi,esi
  59:	e8 00 00 00 00       	call   5e <new_fbgc_int_object_from_substr+0xf>	5a: R_X86_64_PLT32	strtol-0x4
}
  5e:	5a                   	pop    rdx
	return new_fbgc_int_object(strtol(int_str_begin, NULL,base));
  5f:	48 89 c7             	mov    rdi,rax
  62:	eb 9c                	jmp    0 <new_fbgc_int_object>

0000000000000064 <operator_fbgc_int_object2>:

struct fbgc_object * operator_fbgc_int_object2(struct fbgc_object * a,struct fbgc_object * b,fbgc_token op){
  64:	f3 0f 1e fa          	endbr64 
  68:	41 54                	push   r12
  6a:	49 89 fc             	mov    r12,rdi
  6d:	48 89 f7             	mov    rdi,rsi
  70:	53                   	push   rbx
  71:	89 d3                	mov    ebx,edx
  73:	41 50                	push   r8
	//you have to check before calling this function, a and b must be int type 
	int b1 = convert_fbgc_object_to_int(b);
  75:	e8 00 00 00 00       	call   7a <operator_fbgc_int_object2+0x16>	76: R_X86_64_PLT32	convert_fbgc_object_to_int-0x4
	
	int * c =  &cast_fbgc_object_as_int(a)->content;
	
switch(op)
  7a:	8d 53 d3             	lea    edx,[rbx-0x2d]
  7d:	80 fa 09             	cmp    dl,0x9
  80:	0f 87 9c 00 00 00    	ja     122 <operator_fbgc_int_object2+0xbe>
  86:	48 8d 35 00 00 00 00 	lea    rsi,[rip+0x0]        # 8d <operator_fbgc_int_object2+0x29>	89: R_X86_64_PC32	.rodata-0x4
  8d:	0f b6 d2             	movzx  edx,dl
  90:	89 c1                	mov    ecx,eax
  92:	48 63 04 96          	movsxd rax,DWORD PTR [rsi+rdx*4]
  96:	48 01 f0             	add    rax,rsi
  99:	3e ff e0             	notrack jmp rax
{
	case R_SHIFT:
	{
		*c >>= b1;
  9c:	41 d3 7c 24 09       	sar    DWORD PTR [r12+0x9],cl
		break;
  a1:	eb 7f                	jmp    122 <operator_fbgc_int_object2+0xbe>
	}
	case L_SHIFT:
	{
		*c <<= b1;
  a3:	41 d3 64 24 09       	shl    DWORD PTR [r12+0x9],cl
		break;
  a8:	eb 78                	jmp    122 <operator_fbgc_int_object2+0xbe>
		break;
	}
	case SLASHSLASH:
	{
		// a1//b1 = (a1*b1)/(a1+b1)
		return new_fbgc_double_object(*c*b1/(*c+b1+0.0)); 
  aa:	41 8b 44 24 09       	mov    eax,DWORD PTR [r12+0x9]
  af:	0f 57 d2             	xorps  xmm2,xmm2
  b2:	89 c2                	mov    edx,eax
  b4:	0f af d1             	imul   edx,ecx
  b7:	01 c1                	add    ecx,eax
  b9:	f2 0f 2a c9          	cvtsi2sd xmm1,ecx
  bd:	f2 0f 2a c2          	cvtsi2sd xmm0,edx
  c1:	f2 0f 58 ca          	addsd  xmm1,xmm2
  c5:	eb 26                	jmp    ed <operator_fbgc_int_object2+0x89>
	}
	case PLUS:
	{
		*c += b1;
  c7:	41 01 4c 24 09       	add    DWORD PTR [r12+0x9],ecx
		break;
  cc:	eb 54                	jmp    122 <operator_fbgc_int_object2+0xbe>
	}
	case MINUS:
	{
		*c -= b1;
  ce:	41 29 4c 24 09       	sub    DWORD PTR [r12+0x9],ecx
		break;
  d3:	eb 4d                	jmp    122 <operator_fbgc_int_object2+0xbe>
	}
	case STAR:
	{
		*c *= b1;
  d5:	41 0f af 4c 24 09    	imul   ecx,DWORD PTR [r12+0x9]
  db:	41 89 4c 24 09       	mov    DWORD PTR [r12+0x9],ecx
		break;
  e0:	eb 40                	jmp    122 <operator_fbgc_int_object2+0xbe>
	}
	case SLASH:
	{
		return new_fbgc_double_object(((double)*c)/b1);
  e2:	f2 41 0f 2a 44 24 09 	cvtsi2sd xmm0,DWORD PTR [r12+0x9]
  e9:	f2 0f 2a c9          	cvtsi2sd xmm1,ecx
  ed:	f2 0f 5e c1          	divsd  xmm0,xmm1
	}                         
}

	return a;
	//new_fbgc_int_object(c);
}
  f1:	59                   	pop    rcx
  f2:	5b                   	pop    rbx
  f3:	41 5c                	pop    r12
		return new_fbgc_double_object(((double)*c)/b1);
  f5:	e9 00 00 00 00       	jmp    fa <operator_fbgc_int_object2+0x96>	f6: R_X86_64_PLT32	new_fbgc_double_object-0x4
		*c = pow(*c,b1);
  fa:	f2 41 0f 2a 44 24 09 	cvtsi2sd xmm0,DWORD PTR [r12+0x9]
 101:	f2 0f 2a c9          	cvtsi2sd xmm1,ecx
 105:	e8 00 00 00 00       	call   10a <operator_fbgc_int_object2+0xa6>	106: R_X86_64_PLT32	pow-0x4
 10a:	f2 0f 2c c0          	cvttsd2si eax,xmm0
 10e:	41 89 44 24 09       	mov    DWORD PTR [r12+0x9],eax
		break;
 113:	eb 0d                	jmp    122 <operator_fbgc_int_object2+0xbe>
		*c %= b1;
 115:	41 8b 44 24 09       	mov    eax,DWORD PTR [r12+0x9]
 11a:	99                   	cdq    
 11b:	f7 f9                	idiv   ecx
 11d:	41 89 54 24 09       	mov    DWORD PTR [r12+0x9],edx
}
 122:	4c 89 e0             	mov    rax,r12
 125:	5a                   	pop    rdx
 126:	5b                   	pop    rbx
 127:	41 5c                	pop    r12
 129:	c3                   	ret    

000000000000012a <operator_method_int>:
		return a;
	}
    else return new_fbgc_int_object(c);*/
}

int operator_method_int(int a1, int b1,fbgc_token op, struct fbgc_object ** result){
 12a:	f3 0f 1e fa          	endbr64 
	int c = 0;
	fbgc_token result_type = (op<=LO_EQ || op>=EXCLAMATION) ? INT: LOGIC;
 12e:	8d 42 c8             	lea    eax,[rdx-0x38]
int operator_method_int(int a1, int b1,fbgc_token op, struct fbgc_object ** result){
 131:	41 55                	push   r13
	fbgc_token result_type = (op<=LO_EQ || op>=EXCLAMATION) ? INT: LOGIC;
 133:	3c 06                	cmp    al,0x6
int operator_method_int(int a1, int b1,fbgc_token op, struct fbgc_object ** result){
 135:	41 54                	push   r12
	fbgc_token result_type = (op<=LO_EQ || op>=EXCLAMATION) ? INT: LOGIC;
 137:	41 0f 97 c5          	seta   r13b
 13b:	83 ea 2d             	sub    edx,0x2d
int operator_method_int(int a1, int b1,fbgc_token op, struct fbgc_object ** result){
 13e:	55                   	push   rbp
 13f:	48 89 cd             	mov    rbp,rcx
 142:	53                   	push   rbx
	fbgc_token result_type = (op<=LO_EQ || op>=EXCLAMATION) ? INT: LOGIC;
 143:	41 83 c5 02          	add    r13d,0x2
int operator_method_int(int a1, int b1,fbgc_token op, struct fbgc_object ** result){
 147:	41 50                	push   r8
 149:	80 fa 15             	cmp    dl,0x15
 14c:	0f 87 fa 00 00 00    	ja     24c <operator_method_int+0x122>
 152:	48 8d 0d 00 00 00 00 	lea    rcx,[rip+0x0]        # 159 <operator_method_int+0x2f>	155: R_X86_64_PC32	.rodata+0x24
 159:	0f b6 d2             	movzx  edx,dl
 15c:	41 89 fc             	mov    r12d,edi
 15f:	89 f3                	mov    ebx,esi
 161:	48 63 04 91          	movsxd rax,DWORD PTR [rcx+rdx*4]
 165:	48 01 c8             	add    rax,rcx
 168:	3e ff e0             	notrack jmp rax

switch(op)
{
    case R_SHIFT:
    {
        c = a1>>b1;
 16b:	89 f1                	mov    ecx,esi
 16d:	41 d3 fc             	sar    r12d,cl
        break;
 170:	e9 da 00 00 00       	jmp    24f <operator_method_int+0x125>
    }
    case L_SHIFT:
    {
        c = a1<<b1;
 175:	89 f1                	mov    ecx,esi
 177:	41 d3 e4             	shl    r12d,cl
        break;
 17a:	e9 d0 00 00 00       	jmp    24f <operator_method_int+0x125>
    }
    case STARSTAR:
    {
        c = pow(a1,b1);
 17f:	f2 0f 2a c7          	cvtsi2sd xmm0,edi
 183:	f2 0f 2a ce          	cvtsi2sd xmm1,esi
 187:	e8 00 00 00 00       	call   18c <operator_method_int+0x62>	188: R_X86_64_PLT32	pow-0x4
 18c:	f2 44 0f 2c e0       	cvttsd2si r12d,xmm0
        break;
 191:	e9 b9 00 00 00       	jmp    24f <operator_method_int+0x125>
    }
    case SLASHSLASH:
    {
        // a1//b1 = (a1*b1)/(a1+b1)
        *result = new_fbgc_double_object((double)a1*b1/(a1+b1));
 196:	f2 0f 2a ce          	cvtsi2sd xmm1,esi
 19a:	8d 04 37             	lea    eax,[rdi+rsi*1]
 19d:	f2 0f 2a c7          	cvtsi2sd xmm0,edi
 1a1:	f2 0f 59 c1          	mulsd  xmm0,xmm1
 1a5:	f2 0f 2a c8          	cvtsi2sd xmm1,eax
 1a9:	eb 21                	jmp    1cc <operator_method_int+0xa2>
        //break;
        return c; 
    }
    case PLUS:
    {
        c = a1+b1;
 1ab:	41 01 f4             	add    r12d,esi
        break;
 1ae:	e9 9c 00 00 00       	jmp    24f <operator_method_int+0x125>
    }
    case MINUS:
    {
        c = a1-b1;
 1b3:	41 29 f4             	sub    r12d,esi
        break;
 1b6:	e9 94 00 00 00       	jmp    24f <operator_method_int+0x125>
    }
    case STAR:
    {
        c = a1*b1;
 1bb:	44 0f af e6          	imul   r12d,esi
        break;
 1bf:	e9 8b 00 00 00       	jmp    24f <operator_method_int+0x125>
    }
    case SLASH:
    {
        *result = new_fbgc_double_object(((double)a1)/b1);
 1c4:	f2 0f 2a c7          	cvtsi2sd xmm0,edi
 1c8:	f2 0f 2a ce          	cvtsi2sd xmm1,esi
 1cc:	f2 0f 5e c1          	divsd  xmm0,xmm1
 1d0:	e8 00 00 00 00       	call   1d5 <operator_method_int+0xab>	1d1: R_X86_64_PLT32	new_fbgc_double_object-0x4
 1d5:	48 89 45 00          	mov    QWORD PTR [rbp+0x0],rax
        return a1/b1;
 1d9:	44 89 e0             	mov    eax,r12d
 1dc:	99                   	cdq    
 1dd:	f7 fb                	idiv   ebx
 1df:	41 89 c4             	mov    r12d,eax
 1e2:	e9 86 00 00 00       	jmp    26d <operator_method_int+0x143>
        c = pow(a1,b1);
        break;
    }
    case PERCENT:
    {
        c = a1%b1;
 1e7:	89 f8                	mov    eax,edi
 1e9:	99                   	cdq    
 1ea:	f7 fe                	idiv   esi
 1ec:	41 89 d4             	mov    r12d,edx
        break;
 1ef:	eb 5e                	jmp    24f <operator_method_int+0x125>
    }                         
    case LO_EQ:
    {
        c = (a1<=b1);
 1f1:	39 f7                	cmp    edi,esi
 1f3:	41 0f 9e c4          	setle  r12b
 1f7:	eb 06                	jmp    1ff <operator_method_int+0xd5>
        break;
    }
    case GR_EQ:
    {
        c = (a1 >= b1);
 1f9:	39 f7                	cmp    edi,esi
 1fb:	41 0f 9d c4          	setge  r12b
 1ff:	45 0f b6 e4          	movzx  r12d,r12b
        break;
 203:	eb 4a                	jmp    24f <operator_method_int+0x125>
    }
    case EQ_EQ:
    {
        c = (a1 == b1);
 205:	39 f7                	cmp    edi,esi
 207:	eb 33                	jmp    23c <operator_method_int+0x112>
        break;
    }
    case NOT_EQ:
    {
        c = (a1 != b1);
 209:	39 f7                	cmp    edi,esi
 20b:	eb 13                	jmp    220 <operator_method_int+0xf6>
        break;
    }
    case LOWER:
    {
        c = (a1<b1);
 20d:	39 f7                	cmp    edi,esi
 20f:	41 0f 9c c4          	setl   r12b
 213:	eb ea                	jmp    1ff <operator_method_int+0xd5>
        break;
    }        
    case GREATER:
    {
        c = (a1>b1);
 215:	39 f7                	cmp    edi,esi
 217:	41 0f 9f c4          	setg   r12b
 21b:	eb e2                	jmp    1ff <operator_method_int+0xd5>
        break;
    }        
    case PIPE:
    {
        c = (a1 || b1);
 21d:	41 09 f4             	or     r12d,esi
 220:	41 0f 95 c4          	setne  r12b
 224:	eb d9                	jmp    1ff <operator_method_int+0xd5>
        break;
    } 
    case AMPERSAND:
    {
        c = (a1 && b1);
 226:	85 ff                	test   edi,edi
 228:	40 0f 95 c7          	setne  dil
 22c:	45 31 e4             	xor    r12d,r12d
 22f:	85 f6                	test   esi,esi
 231:	41 0f 95 c4          	setne  r12b
 235:	41 21 fc             	and    r12d,edi
        break;
 238:	eb 15                	jmp    24f <operator_method_int+0x125>
    } 
    case EXCLAMATION:
    {
        c = (!a1);   
 23a:	85 ff                	test   edi,edi
 23c:	41 0f 94 c4          	sete   r12b
 240:	eb bd                	jmp    1ff <operator_method_int+0xd5>
        break;
    }
    case TILDE:
    {
        c = ~a1;
 242:	41 f7 d4             	not    r12d
        break;
 245:	eb 08                	jmp    24f <operator_method_int+0x125>
        c = a1;
        break;
    }
    case UMINUS:
    {
        c = -a1;
 247:	41 f7 dc             	neg    r12d
        break;
 24a:	eb 03                	jmp    24f <operator_method_int+0x125>
	int c = 0;
 24c:	45 31 e4             	xor    r12d,r12d
    }
}	

	if(result != NULL){
 24f:	48 85 ed             	test   rbp,rbp
 252:	74 19                	je     26d <operator_method_int+0x143>
				*result = new_fbgc_logic_object(c);
				break;
			}
			case INT:
			{
				*result = new_fbgc_int_object(c);
 254:	44 89 e7             	mov    edi,r12d
		switch(result_type){
 257:	41 80 fd 03          	cmp    r13b,0x3
 25b:	74 07                	je     264 <operator_method_int+0x13a>
				*result = new_fbgc_logic_object(c);
 25d:	e8 00 00 00 00       	call   262 <operator_method_int+0x138>	25e: R_X86_64_PLT32	new_fbgc_logic_object-0x4
 262:	eb 05                	jmp    269 <operator_method_int+0x13f>
				*result = new_fbgc_int_object(c);
 264:	e8 00 00 00 00       	call   269 <operator_method_int+0x13f>	265: R_X86_64_PLT32	new_fbgc_int_object-0x4
 269:	48 89 45 00          	mov    QWORD PTR [rbp+0x0],rax
		}
	}
	return c;   


}
 26d:	5a                   	pop    rdx
 26e:	44 89 e0             	mov    eax,r12d
 271:	5b                   	pop    rbx
 272:	5d                   	pop    rbp
 273:	41 5c                	pop    r12
 275:	41 5d                	pop    r13
 277:	c3                   	ret    

0000000000000278 <operator_fbgc_int_object>:
struct fbgc_object * operator_fbgc_int_object(struct fbgc_object * a,struct fbgc_object * b,fbgc_token op){
 278:	f3 0f 1e fa          	endbr64 
 27c:	53                   	push   rbx
	int a1 = (a->type != LOGIC) ? cast_fbgc_object_as_int(a)->content:(int)(cast_fbgc_object_as_logic(a)->content);	
 27d:	80 3f 02             	cmp    BYTE PTR [rdi],0x2
struct fbgc_object * operator_fbgc_int_object(struct fbgc_object * a,struct fbgc_object * b,fbgc_token op){
 280:	48 89 fb             	mov    rbx,rdi
	int a1 = (a->type != LOGIC) ? cast_fbgc_object_as_int(a)->content:(int)(cast_fbgc_object_as_logic(a)->content);	
 283:	74 05                	je     28a <operator_fbgc_int_object+0x12>
 285:	8b 7f 09             	mov    edi,DWORD PTR [rdi+0x9]
 288:	eb 04                	jmp    28e <operator_fbgc_int_object+0x16>
 28a:	0f be 7f 09          	movsx  edi,BYTE PTR [rdi+0x9]
	int b1 = (b->type != LOGIC) ? cast_fbgc_object_as_int(b)->content:(int)(cast_fbgc_object_as_logic(b)->content);
 28e:	80 3e 02             	cmp    BYTE PTR [rsi],0x2
 291:	74 05                	je     298 <operator_fbgc_int_object+0x20>
 293:	8b 76 09             	mov    esi,DWORD PTR [rsi+0x9]
 296:	eb 04                	jmp    29c <operator_fbgc_int_object+0x24>
 298:	0f be 76 09          	movsx  esi,BYTE PTR [rsi+0x9]
	cast_fbgc_object_as_int(a)->content = operator_method_int(a1,b1,op,NULL);
 29c:	0f b6 d2             	movzx  edx,dl
 29f:	31 c9                	xor    ecx,ecx
 2a1:	e8 00 00 00 00       	call   2a6 <operator_fbgc_int_object+0x2e>	2a2: R_X86_64_PLT32	operator_method_int-0x4
 2a6:	89 43 09             	mov    DWORD PTR [rbx+0x9],eax
}
 2a9:	31 c0                	xor    eax,eax
 2ab:	5b                   	pop    rbx
 2ac:	c3                   	ret    

00000000000002ad <operator_STARSTAR_fbgc_int>:
	return a1 >> b1;
}
inline int operator_L_SHIFT_fbgc_int(int a1,int b1){
	return (a1<<b1); 
}
int operator_STARSTAR_fbgc_int(int a1,int b1){
 2ad:	f3 0f 1e fa          	endbr64 
	return (pow(a1,b1));  
 2b1:	f2 0f 2a c7          	cvtsi2sd xmm0,edi
int operator_STARSTAR_fbgc_int(int a1,int b1){
 2b5:	50                   	push   rax
	return (pow(a1,b1));  
 2b6:	f2 0f 2a ce          	cvtsi2sd xmm1,esi
 2ba:	e8 00 00 00 00       	call   2bf <operator_STARSTAR_fbgc_int+0x12>	2bb: R_X86_64_PLT32	pow-0x4
}
 2bf:	5a                   	pop    rdx
	return (pow(a1,b1));  
 2c0:	f2 0f 2c c0          	cvttsd2si eax,xmm0
}
 2c4:	c3                   	ret    

00000000000002c5 <return_fbgc_object_operator_helper>:
	return -a1; 
}



struct fbgc_object * return_fbgc_object_operator_helper(fbgc_token return_type, void * c, struct fbgc_object * result){
 2c5:	f3 0f 1e fa          	endbr64 
 2c9:	48 89 d0             	mov    rax,rdx
	if(result == NULL)
 2cc:	48 85 d2             	test   rdx,rdx
 2cf:	75 29                	jne    2fa <return_fbgc_object_operator_helper+0x35>
	{
		switch(return_type){
 2d1:	40 80 ff 03          	cmp    dil,0x3
 2d5:	74 13                	je     2ea <return_fbgc_object_operator_helper+0x25>
 2d7:	40 80 ff 04          	cmp    dil,0x4
 2db:	74 14                	je     2f1 <return_fbgc_object_operator_helper+0x2c>
 2dd:	40 80 ff 02          	cmp    dil,0x2
 2e1:	75 41                	jne    324 <return_fbgc_object_operator_helper+0x5f>
			case LOGIC:{
				int *q = c;
				return new_fbgc_logic_object(*q);
 2e3:	8b 3e                	mov    edi,DWORD PTR [rsi]
 2e5:	e9 00 00 00 00       	jmp    2ea <return_fbgc_object_operator_helper+0x25>	2e6: R_X86_64_PLT32	new_fbgc_logic_object-0x4
			}
			case INT:{
				int * q = c;
				return new_fbgc_int_object(*q);
 2ea:	8b 3e                	mov    edi,DWORD PTR [rsi]
 2ec:	e9 0f fd ff ff       	jmp    0 <new_fbgc_int_object>
			} 
			case DOUBLE:{
				double *q = c;
				return new_fbgc_double_object(*q);
 2f1:	f2 0f 10 06          	movsd  xmm0,QWORD PTR [rsi]
 2f5:	e9 00 00 00 00       	jmp    2fa <return_fbgc_object_operator_helper+0x35>	2f6: R_X86_64_PLT32	new_fbgc_double_object-0x4
			}
		}
	} 
	else{
		switch(get_fbgc_object_type(result)){
 2fa:	8a 12                	mov    dl,BYTE PTR [rdx]
 2fc:	83 e2 7f             	and    edx,0x7f
 2ff:	80 fa 03             	cmp    dl,0x3
 302:	74 10                	je     314 <return_fbgc_object_operator_helper+0x4f>
 304:	80 fa 04             	cmp    dl,0x4
 307:	74 11                	je     31a <return_fbgc_object_operator_helper+0x55>
 309:	80 fa 02             	cmp    dl,0x2
 30c:	75 16                	jne    324 <return_fbgc_object_operator_helper+0x5f>
			case LOGIC:{
				int *q = c;
				cast_fbgc_object_as_logic(result)->content = *q;
 30e:	8b 16                	mov    edx,DWORD PTR [rsi]
 310:	88 50 09             	mov    BYTE PTR [rax+0x9],dl
				break;
 313:	c3                   	ret    
			}
			case INT: {
				int *q = c;
				cast_fbgc_object_as_int(result)->content = *q;
 314:	8b 16                	mov    edx,DWORD PTR [rsi]
 316:	89 50 09             	mov    DWORD PTR [rax+0x9],edx
				break;
 319:	c3                   	ret    
			}
			case DOUBLE:{
				double *q = c;
				cast_fbgc_object_as_double(result)->content = *q;
 31a:	f2 0f 10 06          	movsd  xmm0,QWORD PTR [rsi]
 31e:	f2 0f 11 40 09       	movsd  QWORD PTR [rax+0x9],xmm0
				break;
 323:	c3                   	ret    
			}
		}		
		
		return result;
	}	
}
 324:	c3                   	ret    

0000000000000325 <operator_R_SHIFT_fbgc_int_object>:


struct fbgc_object * operator_R_SHIFT_fbgc_int_object(int a1, int b1,struct fbgc_object * result){
 325:	f3 0f 1e fa          	endbr64 
	return a1 >> b1;
 329:	89 f1                	mov    ecx,esi
struct fbgc_object * operator_R_SHIFT_fbgc_int_object(int a1, int b1,struct fbgc_object * result){
 32b:	48 83 ec 18          	sub    rsp,0x18
 32f:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 338:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 33d:	31 c0                	xor    eax,eax
	return a1 >> b1;
 33f:	d3 ff                	sar    edi,cl
	int c = operator_R_SHIFT_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);
 341:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return a1 >> b1;
 346:	89 7c 24 04          	mov    DWORD PTR [rsp+0x4],edi
	return return_fbgc_object_operator_helper(INT,&c,result);
 34a:	bf 03 00 00 00       	mov    edi,0x3
 34f:	e8 00 00 00 00       	call   354 <operator_R_SHIFT_fbgc_int_object+0x2f>	350: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 354:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 359:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 362:	74 05                	je     369 <operator_R_SHIFT_fbgc_int_object+0x44>
 364:	e8 00 00 00 00       	call   369 <operator_R_SHIFT_fbgc_int_object+0x44>	365: R_X86_64_PLT32	__stack_chk_fail-0x4
 369:	48 83 c4 18          	add    rsp,0x18
 36d:	c3                   	ret    

000000000000036e <operator_L_SHIFT_fbgc_int_object>:
struct fbgc_object * operator_L_SHIFT_fbgc_int_object(int a1, int b1, struct fbgc_object * result){
 36e:	f3 0f 1e fa          	endbr64 
	return (a1<<b1); 
 372:	89 f1                	mov    ecx,esi
struct fbgc_object * operator_L_SHIFT_fbgc_int_object(int a1, int b1, struct fbgc_object * result){
 374:	48 83 ec 18          	sub    rsp,0x18
 378:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 381:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 386:	31 c0                	xor    eax,eax
	return (a1<<b1); 
 388:	d3 e7                	shl    edi,cl
	int c = operator_L_SHIFT_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);
 38a:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1<<b1); 
 38f:	89 7c 24 04          	mov    DWORD PTR [rsp+0x4],edi
	return return_fbgc_object_operator_helper(INT,&c,result);
 393:	bf 03 00 00 00       	mov    edi,0x3
 398:	e8 00 00 00 00       	call   39d <operator_L_SHIFT_fbgc_int_object+0x2f>	399: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 39d:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 3a2:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 3ab:	74 05                	je     3b2 <operator_L_SHIFT_fbgc_int_object+0x44>
 3ad:	e8 00 00 00 00       	call   3b2 <operator_L_SHIFT_fbgc_int_object+0x44>	3ae: R_X86_64_PLT32	__stack_chk_fail-0x4
 3b2:	48 83 c4 18          	add    rsp,0x18
 3b6:	c3                   	ret    

00000000000003b7 <operator_STARSTAR_fbgc_int_object>:
struct fbgc_object * operator_STARSTAR_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 3b7:	f3 0f 1e fa          	endbr64 
 3bb:	48 83 ec 28          	sub    rsp,0x28
 3bf:	48 89 54 24 08       	mov    QWORD PTR [rsp+0x8],rdx
 3c4:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 3cd:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 3d2:	31 c0                	xor    eax,eax
	int c = operator_STARSTAR_fbgc_int(a1,b1);
 3d4:	e8 00 00 00 00       	call   3d9 <operator_STARSTAR_fbgc_int_object+0x22>	3d5: R_X86_64_PLT32	operator_STARSTAR_fbgc_int-0x4
	return return_fbgc_object_operator_helper(INT,&c,result);
 3d9:	48 8b 54 24 08       	mov    rdx,QWORD PTR [rsp+0x8]
 3de:	48 8d 74 24 14       	lea    rsi,[rsp+0x14]
 3e3:	bf 03 00 00 00       	mov    edi,0x3
	int c = operator_STARSTAR_fbgc_int(a1,b1);
 3e8:	89 44 24 14          	mov    DWORD PTR [rsp+0x14],eax
	return return_fbgc_object_operator_helper(INT,&c,result);
 3ec:	e8 00 00 00 00       	call   3f1 <operator_STARSTAR_fbgc_int_object+0x3a>	3ed: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 3f1:	48 8b 4c 24 18       	mov    rcx,QWORD PTR [rsp+0x18]
 3f6:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 3ff:	74 05                	je     406 <operator_STARSTAR_fbgc_int_object+0x4f>
 401:	e8 00 00 00 00       	call   406 <operator_STARSTAR_fbgc_int_object+0x4f>	402: R_X86_64_PLT32	__stack_chk_fail-0x4
 406:	48 83 c4 28          	add    rsp,0x28
 40a:	c3                   	ret    

000000000000040b <operator_CARET_fbgc_int_object>:
 40b:	f3 0f 1e fa          	endbr64 
 40f:	eb a6                	jmp    3b7 <operator_STARSTAR_fbgc_int_object>

0000000000000411 <operator_SLASHSLASH_fbgc_int_object>:
struct fbgc_object * operator_SLASHSLASH_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 411:	f3 0f 1e fa          	endbr64 
	return a1 >> b1;
 415:	89 f1                	mov    ecx,esi
struct fbgc_object * operator_SLASHSLASH_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 417:	48 83 ec 18          	sub    rsp,0x18
 41b:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 424:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 429:	31 c0                	xor    eax,eax
	return a1 >> b1;
 42b:	d3 ff                	sar    edi,cl
	double c = operator_R_SHIFT_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(DOUBLE,&c,result);
 42d:	48 89 e6             	mov    rsi,rsp
	double c = operator_R_SHIFT_fbgc_int(a1,b1);
 430:	f2 0f 2a c7          	cvtsi2sd xmm0,edi
	return return_fbgc_object_operator_helper(DOUBLE,&c,result);
 434:	bf 04 00 00 00       	mov    edi,0x4
	double c = operator_R_SHIFT_fbgc_int(a1,b1);
 439:	f2 0f 11 04 24       	movsd  QWORD PTR [rsp],xmm0
	return return_fbgc_object_operator_helper(DOUBLE,&c,result);
 43e:	e8 00 00 00 00       	call   443 <operator_SLASHSLASH_fbgc_int_object+0x32>	43f: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 443:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 448:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 451:	74 05                	je     458 <operator_SLASHSLASH_fbgc_int_object+0x47>
 453:	e8 00 00 00 00       	call   458 <operator_SLASHSLASH_fbgc_int_object+0x47>	454: R_X86_64_PLT32	__stack_chk_fail-0x4
 458:	48 83 c4 18          	add    rsp,0x18
 45c:	c3                   	ret    

000000000000045d <operator_PLUS_fbgc_int_object>:
struct fbgc_object * operator_PLUS_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 45d:	f3 0f 1e fa          	endbr64 
 461:	48 83 ec 18          	sub    rsp,0x18
	return (a1+b1);	
 465:	01 f7                	add    edi,esi
struct fbgc_object * operator_PLUS_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 467:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 470:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 475:	31 c0                	xor    eax,eax
	int c = operator_PLUS_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);	
 477:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1+b1);	
 47c:	89 7c 24 04          	mov    DWORD PTR [rsp+0x4],edi
	return return_fbgc_object_operator_helper(INT,&c,result);	
 480:	bf 03 00 00 00       	mov    edi,0x3
 485:	e8 00 00 00 00       	call   48a <operator_PLUS_fbgc_int_object+0x2d>	486: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 48a:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 48f:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 498:	74 05                	je     49f <operator_PLUS_fbgc_int_object+0x42>
 49a:	e8 00 00 00 00       	call   49f <operator_PLUS_fbgc_int_object+0x42>	49b: R_X86_64_PLT32	__stack_chk_fail-0x4
 49f:	48 83 c4 18          	add    rsp,0x18
 4a3:	c3                   	ret    

00000000000004a4 <operator_MINUS_fbgc_int_object>:
struct fbgc_object * operator_MINUS_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 4a4:	f3 0f 1e fa          	endbr64 
 4a8:	48 83 ec 18          	sub    rsp,0x18
	return (a1-b1);       
 4ac:	29 f7                	sub    edi,esi
struct fbgc_object * operator_MINUS_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 4ae:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 4b7:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 4bc:	31 c0                	xor    eax,eax
	int c = operator_MINUS_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);
 4be:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1-b1);       
 4c3:	89 7c 24 04          	mov    DWORD PTR [rsp+0x4],edi
	return return_fbgc_object_operator_helper(INT,&c,result);
 4c7:	bf 03 00 00 00       	mov    edi,0x3
 4cc:	e8 00 00 00 00       	call   4d1 <operator_MINUS_fbgc_int_object+0x2d>	4cd: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 4d1:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 4d6:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 4df:	74 05                	je     4e6 <operator_MINUS_fbgc_int_object+0x42>
 4e1:	e8 00 00 00 00       	call   4e6 <operator_MINUS_fbgc_int_object+0x42>	4e2: R_X86_64_PLT32	__stack_chk_fail-0x4
 4e6:	48 83 c4 18          	add    rsp,0x18
 4ea:	c3                   	ret    

00000000000004eb <operator_STAR_fbgc_int_object>:
struct fbgc_object * operator_STAR_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 4eb:	f3 0f 1e fa          	endbr64 
	return (a1*b1);       
 4ef:	0f af fe             	imul   edi,esi
struct fbgc_object * operator_STAR_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 4f2:	48 83 ec 18          	sub    rsp,0x18
 4f6:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 4ff:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 504:	31 c0                	xor    eax,eax
	int c = operator_STAR_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);
 506:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	int c = operator_STAR_fbgc_int(a1,b1);
 50b:	89 7c 24 04          	mov    DWORD PTR [rsp+0x4],edi
	return return_fbgc_object_operator_helper(INT,&c,result);
 50f:	bf 03 00 00 00       	mov    edi,0x3
 514:	e8 00 00 00 00       	call   519 <operator_STAR_fbgc_int_object+0x2e>	515: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 519:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 51e:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 527:	74 05                	je     52e <operator_STAR_fbgc_int_object+0x43>
 529:	e8 00 00 00 00       	call   52e <operator_STAR_fbgc_int_object+0x43>	52a: R_X86_64_PLT32	__stack_chk_fail-0x4
 52e:	48 83 c4 18          	add    rsp,0x18
 532:	c3                   	ret    

0000000000000533 <operator_SLASH_fbgc_int_object>:
struct fbgc_object * operator_SLASH_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 533:	f3 0f 1e fa          	endbr64 
	return (double)a1/b1;      
 537:	f2 0f 2a ce          	cvtsi2sd xmm1,esi
struct fbgc_object * operator_SLASH_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 53b:	48 83 ec 18          	sub    rsp,0x18
 53f:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 548:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 54d:	31 c0                	xor    eax,eax
	return (double)a1/b1;      
 54f:	f2 0f 2a c7          	cvtsi2sd xmm0,edi
	double c = operator_SLASH_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(DOUBLE,&c,result);
 553:	48 89 e6             	mov    rsi,rsp
 556:	bf 04 00 00 00       	mov    edi,0x4
	return (double)a1/b1;      
 55b:	f2 0f 5e c1          	divsd  xmm0,xmm1
	double c = operator_SLASH_fbgc_int(a1,b1);
 55f:	f2 0f 11 04 24       	movsd  QWORD PTR [rsp],xmm0
	return return_fbgc_object_operator_helper(DOUBLE,&c,result);
 564:	e8 00 00 00 00       	call   569 <operator_SLASH_fbgc_int_object+0x36>	565: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 569:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 56e:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 577:	74 05                	je     57e <operator_SLASH_fbgc_int_object+0x4b>
 579:	e8 00 00 00 00       	call   57e <operator_SLASH_fbgc_int_object+0x4b>	57a: R_X86_64_PLT32	__stack_chk_fail-0x4
 57e:	48 83 c4 18          	add    rsp,0x18
 582:	c3                   	ret    

0000000000000583 <operator_PERCENT_fbgc_int_object>:
struct fbgc_object * operator_CARET_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
	int c = operator_CARET_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);
}
struct fbgc_object * operator_PERCENT_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 583:	f3 0f 1e fa          	endbr64 
 587:	48 83 ec 18          	sub    rsp,0x18
 58b:	49 89 d0             	mov    r8,rdx
 58e:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 597:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 59c:	31 c0                	xor    eax,eax
	return (a1%b1);      
 59e:	89 f8                	mov    eax,edi
	int c = operator_PERCENT_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);
 5a0:	bf 03 00 00 00       	mov    edi,0x3
	return (a1%b1);      
 5a5:	99                   	cdq    
 5a6:	f7 fe                	idiv   esi
	return return_fbgc_object_operator_helper(INT,&c,result);
 5a8:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	int c = operator_PERCENT_fbgc_int(a1,b1);
 5ad:	89 54 24 04          	mov    DWORD PTR [rsp+0x4],edx
	return return_fbgc_object_operator_helper(INT,&c,result);
 5b1:	4c 89 c2             	mov    rdx,r8
 5b4:	e8 00 00 00 00       	call   5b9 <operator_PERCENT_fbgc_int_object+0x36>	5b5: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 5b9:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 5be:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 5c7:	74 05                	je     5ce <operator_PERCENT_fbgc_int_object+0x4b>
 5c9:	e8 00 00 00 00       	call   5ce <operator_PERCENT_fbgc_int_object+0x4b>	5ca: R_X86_64_PLT32	__stack_chk_fail-0x4
 5ce:	48 83 c4 18          	add    rsp,0x18
 5d2:	c3                   	ret    

00000000000005d3 <operator_LO_EQ_fbgc_int_object>:
struct fbgc_object * operator_LO_EQ_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 5d3:	f3 0f 1e fa          	endbr64 
 5d7:	48 83 ec 18          	sub    rsp,0x18
 5db:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 5e4:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 5e9:	31 c0                	xor    eax,eax
	return (a1<=b1);
 5eb:	31 c0                	xor    eax,eax
 5ed:	39 f7                	cmp    edi,esi
	int c = operator_LO_EQ_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 5ef:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1<=b1);
 5f4:	0f 9e c0             	setle  al
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 5f7:	bf 02 00 00 00       	mov    edi,0x2
	int c = operator_LO_EQ_fbgc_int(a1,b1);
 5fc:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 600:	e8 00 00 00 00       	call   605 <operator_LO_EQ_fbgc_int_object+0x32>	601: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 605:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 60a:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 613:	74 05                	je     61a <operator_LO_EQ_fbgc_int_object+0x47>
 615:	e8 00 00 00 00       	call   61a <operator_LO_EQ_fbgc_int_object+0x47>	616: R_X86_64_PLT32	__stack_chk_fail-0x4
 61a:	48 83 c4 18          	add    rsp,0x18
 61e:	c3                   	ret    

000000000000061f <operator_GR_EQ_fbgc_int_object>:
struct fbgc_object * operator_GR_EQ_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 61f:	f3 0f 1e fa          	endbr64 
 623:	48 83 ec 18          	sub    rsp,0x18
 627:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 630:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 635:	31 c0                	xor    eax,eax
	return (a1>=b1);
 637:	31 c0                	xor    eax,eax
 639:	39 f7                	cmp    edi,esi
	int c = operator_GR_EQ_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 63b:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1>=b1);
 640:	0f 9d c0             	setge  al
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 643:	bf 02 00 00 00       	mov    edi,0x2
	int c = operator_GR_EQ_fbgc_int(a1,b1);
 648:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 64c:	e8 00 00 00 00       	call   651 <operator_GR_EQ_fbgc_int_object+0x32>	64d: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 651:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 656:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 65f:	74 05                	je     666 <operator_GR_EQ_fbgc_int_object+0x47>
 661:	e8 00 00 00 00       	call   666 <operator_GR_EQ_fbgc_int_object+0x47>	662: R_X86_64_PLT32	__stack_chk_fail-0x4
 666:	48 83 c4 18          	add    rsp,0x18
 66a:	c3                   	ret    

000000000000066b <operator_EQ_EQ_fbgc_int_object>:
struct fbgc_object * operator_EQ_EQ_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 66b:	f3 0f 1e fa          	endbr64 
 66f:	48 83 ec 18          	sub    rsp,0x18
 673:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 67c:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 681:	31 c0                	xor    eax,eax
	return (a1==b1);
 683:	31 c0                	xor    eax,eax
 685:	39 f7                	cmp    edi,esi
	int c = operator_EQ_EQ_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 687:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1==b1);
 68c:	0f 94 c0             	sete   al
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 68f:	bf 02 00 00 00       	mov    edi,0x2
	int c = operator_EQ_EQ_fbgc_int(a1,b1);
 694:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 698:	e8 00 00 00 00       	call   69d <operator_EQ_EQ_fbgc_int_object+0x32>	699: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 69d:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 6a2:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 6ab:	74 05                	je     6b2 <operator_EQ_EQ_fbgc_int_object+0x47>
 6ad:	e8 00 00 00 00       	call   6b2 <operator_EQ_EQ_fbgc_int_object+0x47>	6ae: R_X86_64_PLT32	__stack_chk_fail-0x4
 6b2:	48 83 c4 18          	add    rsp,0x18
 6b6:	c3                   	ret    

00000000000006b7 <operator_NOT_EQ_fbgc_int_object>:
struct fbgc_object * operator_NOT_EQ_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 6b7:	f3 0f 1e fa          	endbr64 
 6bb:	48 83 ec 18          	sub    rsp,0x18
 6bf:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 6c8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 6cd:	31 c0                	xor    eax,eax
	return (a1!=b1);
 6cf:	31 c0                	xor    eax,eax
 6d1:	39 f7                	cmp    edi,esi
	int c = operator_NOT_EQ_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 6d3:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1!=b1);
 6d8:	0f 95 c0             	setne  al
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 6db:	bf 02 00 00 00       	mov    edi,0x2
	int c = operator_NOT_EQ_fbgc_int(a1,b1);
 6e0:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 6e4:	e8 00 00 00 00       	call   6e9 <operator_NOT_EQ_fbgc_int_object+0x32>	6e5: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 6e9:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 6ee:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 6f7:	74 05                	je     6fe <operator_NOT_EQ_fbgc_int_object+0x47>
 6f9:	e8 00 00 00 00       	call   6fe <operator_NOT_EQ_fbgc_int_object+0x47>	6fa: R_X86_64_PLT32	__stack_chk_fail-0x4
 6fe:	48 83 c4 18          	add    rsp,0x18
 702:	c3                   	ret    

0000000000000703 <operator_LOWER_fbgc_int_object>:
struct fbgc_object * operator_LOWER_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 703:	f3 0f 1e fa          	endbr64 
 707:	48 83 ec 18          	sub    rsp,0x18
 70b:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 714:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 719:	31 c0                	xor    eax,eax
	return (a1<b1);
 71b:	31 c0                	xor    eax,eax
 71d:	39 f7                	cmp    edi,esi
	int c = operator_LOWER_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 71f:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1<b1);
 724:	0f 9c c0             	setl   al
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 727:	bf 02 00 00 00       	mov    edi,0x2
	int c = operator_LOWER_fbgc_int(a1,b1);
 72c:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 730:	e8 00 00 00 00       	call   735 <operator_LOWER_fbgc_int_object+0x32>	731: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 735:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 73a:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 743:	74 05                	je     74a <operator_LOWER_fbgc_int_object+0x47>
 745:	e8 00 00 00 00       	call   74a <operator_LOWER_fbgc_int_object+0x47>	746: R_X86_64_PLT32	__stack_chk_fail-0x4
 74a:	48 83 c4 18          	add    rsp,0x18
 74e:	c3                   	ret    

000000000000074f <operator_GREATER_fbgc_int_object>:
struct fbgc_object * operator_GREATER_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 74f:	f3 0f 1e fa          	endbr64 
 753:	48 83 ec 18          	sub    rsp,0x18
 757:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 760:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 765:	31 c0                	xor    eax,eax
	return (a1>b1);
 767:	31 c0                	xor    eax,eax
 769:	39 f7                	cmp    edi,esi
	int c = operator_GREATER_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 76b:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1>b1);
 770:	0f 9f c0             	setg   al
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 773:	bf 02 00 00 00       	mov    edi,0x2
	int c = operator_GREATER_fbgc_int(a1,b1);
 778:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
	return return_fbgc_object_operator_helper(LOGIC,&c,result);
 77c:	e8 00 00 00 00       	call   781 <operator_GREATER_fbgc_int_object+0x32>	77d: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 781:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 786:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 78f:	74 05                	je     796 <operator_GREATER_fbgc_int_object+0x47>
 791:	e8 00 00 00 00       	call   796 <operator_GREATER_fbgc_int_object+0x47>	792: R_X86_64_PLT32	__stack_chk_fail-0x4
 796:	48 83 c4 18          	add    rsp,0x18
 79a:	c3                   	ret    

000000000000079b <operator_PIPE_fbgc_int_object>:
struct fbgc_object * operator_PIPE_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 79b:	f3 0f 1e fa          	endbr64 
 79f:	48 83 ec 18          	sub    rsp,0x18
 7a3:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 7ac:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 7b1:	31 c0                	xor    eax,eax
	return (a1||b1); 
 7b3:	31 c0                	xor    eax,eax
 7b5:	09 f7                	or     edi,esi
	int c = operator_PIPE_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(LOGIC,&c,result);	
 7b7:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1||b1); 
 7bc:	0f 95 c0             	setne  al
	return return_fbgc_object_operator_helper(LOGIC,&c,result);	
 7bf:	bf 02 00 00 00       	mov    edi,0x2
	int c = operator_PIPE_fbgc_int(a1,b1);
 7c4:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
	return return_fbgc_object_operator_helper(LOGIC,&c,result);	
 7c8:	e8 00 00 00 00       	call   7cd <operator_PIPE_fbgc_int_object+0x32>	7c9: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 7cd:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 7d2:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 7db:	74 05                	je     7e2 <operator_PIPE_fbgc_int_object+0x47>
 7dd:	e8 00 00 00 00       	call   7e2 <operator_PIPE_fbgc_int_object+0x47>	7de: R_X86_64_PLT32	__stack_chk_fail-0x4
 7e2:	48 83 c4 18          	add    rsp,0x18
 7e6:	c3                   	ret    

00000000000007e7 <operator_AMPERSAND_fbgc_int_object>:
struct fbgc_object * operator_AMPERSAND_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 7e7:	f3 0f 1e fa          	endbr64 
 7eb:	48 83 ec 18          	sub    rsp,0x18
 7ef:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 7f8:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 7fd:	31 c0                	xor    eax,eax
	return (a1&&b1);
 7ff:	85 ff                	test   edi,edi
	int c = operator_AMPERSAND_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(LOGIC,&c,result);		
 801:	bf 02 00 00 00       	mov    edi,0x2
	return (a1&&b1);
 806:	0f 95 c1             	setne  cl
 809:	31 c0                	xor    eax,eax
 80b:	85 f6                	test   esi,esi
 80d:	0f 95 c0             	setne  al
	return return_fbgc_object_operator_helper(LOGIC,&c,result);		
 810:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (a1&&b1);
 815:	21 c8                	and    eax,ecx
 817:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
	return return_fbgc_object_operator_helper(LOGIC,&c,result);		
 81b:	e8 00 00 00 00       	call   820 <operator_AMPERSAND_fbgc_int_object+0x39>	81c: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 820:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 825:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 82e:	74 05                	je     835 <operator_AMPERSAND_fbgc_int_object+0x4e>
 830:	e8 00 00 00 00       	call   835 <operator_AMPERSAND_fbgc_int_object+0x4e>	831: R_X86_64_PLT32	__stack_chk_fail-0x4
 835:	48 83 c4 18          	add    rsp,0x18
 839:	c3                   	ret    

000000000000083a <operator_EXCLAMATION_fbgc_int_object>:
struct fbgc_object * operator_EXCLAMATION_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 83a:	f3 0f 1e fa          	endbr64 
 83e:	48 83 ec 18          	sub    rsp,0x18
 842:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 84b:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 850:	31 c0                	xor    eax,eax
	return !a1;
 852:	31 c0                	xor    eax,eax
 854:	85 ff                	test   edi,edi
	int c = operator_EXCLAMATION_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(LOGIC,&c,result);	
 856:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return !a1;
 85b:	0f 94 c0             	sete   al
	return return_fbgc_object_operator_helper(LOGIC,&c,result);	
 85e:	bf 02 00 00 00       	mov    edi,0x2
	int c = operator_EXCLAMATION_fbgc_int(a1,b1);
 863:	89 44 24 04          	mov    DWORD PTR [rsp+0x4],eax
	return return_fbgc_object_operator_helper(LOGIC,&c,result);	
 867:	e8 00 00 00 00       	call   86c <operator_EXCLAMATION_fbgc_int_object+0x32>	868: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 86c:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 871:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 87a:	74 05                	je     881 <operator_EXCLAMATION_fbgc_int_object+0x47>
 87c:	e8 00 00 00 00       	call   881 <operator_EXCLAMATION_fbgc_int_object+0x47>	87d: R_X86_64_PLT32	__stack_chk_fail-0x4
 881:	48 83 c4 18          	add    rsp,0x18
 885:	c3                   	ret    

0000000000000886 <operator_TILDE_fbgc_int_object>:
struct fbgc_object * operator_TILDE_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 886:	f3 0f 1e fa          	endbr64 
 88a:	48 83 ec 18          	sub    rsp,0x18
	return (~a1); 
 88e:	f7 d7                	not    edi
struct fbgc_object * operator_TILDE_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 890:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 899:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 89e:	31 c0                	xor    eax,eax
	int c = operator_TILDE_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);	
 8a0:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return (~a1); 
 8a5:	89 7c 24 04          	mov    DWORD PTR [rsp+0x4],edi
	return return_fbgc_object_operator_helper(INT,&c,result);	
 8a9:	bf 03 00 00 00       	mov    edi,0x3
 8ae:	e8 00 00 00 00       	call   8b3 <operator_TILDE_fbgc_int_object+0x2d>	8af: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 8b3:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 8b8:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 8c1:	74 05                	je     8c8 <operator_TILDE_fbgc_int_object+0x42>
 8c3:	e8 00 00 00 00       	call   8c8 <operator_TILDE_fbgc_int_object+0x42>	8c4: R_X86_64_PLT32	__stack_chk_fail-0x4
 8c8:	48 83 c4 18          	add    rsp,0x18
 8cc:	c3                   	ret    

00000000000008cd <operator_UPLUS_fbgc_int_object>:
struct fbgc_object * operator_UPLUS_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 8cd:	f3 0f 1e fa          	endbr64 
 8d1:	48 83 ec 18          	sub    rsp,0x18
 8d5:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 8de:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 8e3:	31 c0                	xor    eax,eax
	int c = operator_UPLUS_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);	
 8e5:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	int c = operator_UPLUS_fbgc_int(a1,b1);
 8ea:	89 7c 24 04          	mov    DWORD PTR [rsp+0x4],edi
	return return_fbgc_object_operator_helper(INT,&c,result);	
 8ee:	bf 03 00 00 00       	mov    edi,0x3
 8f3:	e8 00 00 00 00       	call   8f8 <operator_UPLUS_fbgc_int_object+0x2b>	8f4: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 8f8:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 8fd:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 906:	74 05                	je     90d <operator_UPLUS_fbgc_int_object+0x40>
 908:	e8 00 00 00 00       	call   90d <operator_UPLUS_fbgc_int_object+0x40>	909: R_X86_64_PLT32	__stack_chk_fail-0x4
 90d:	48 83 c4 18          	add    rsp,0x18
 911:	c3                   	ret    

0000000000000912 <operator_UMINUS_fbgc_int_object>:
struct fbgc_object * operator_UMINUS_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 912:	f3 0f 1e fa          	endbr64 
 916:	48 83 ec 18          	sub    rsp,0x18
	return -a1; 
 91a:	f7 df                	neg    edi
struct fbgc_object * operator_UMINUS_fbgc_int_object(int a1,int b1, struct fbgc_object * result){
 91c:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 925:	48 89 44 24 08       	mov    QWORD PTR [rsp+0x8],rax
 92a:	31 c0                	xor    eax,eax
	int c = operator_UMINUS_fbgc_int(a1,b1);
	return return_fbgc_object_operator_helper(INT,&c,result);	
 92c:	48 8d 74 24 04       	lea    rsi,[rsp+0x4]
	return -a1; 
 931:	89 7c 24 04          	mov    DWORD PTR [rsp+0x4],edi
	return return_fbgc_object_operator_helper(INT,&c,result);	
 935:	bf 03 00 00 00       	mov    edi,0x3
 93a:	e8 00 00 00 00       	call   93f <operator_UMINUS_fbgc_int_object+0x2d>	93b: R_X86_64_PLT32	return_fbgc_object_operator_helper-0x4
}
 93f:	48 8b 4c 24 08       	mov    rcx,QWORD PTR [rsp+0x8]
 944:	64 48 33 0c 25 28 00 00 00 	xor    rcx,QWORD PTR fs:0x28
 94d:	74 05                	je     954 <operator_UMINUS_fbgc_int_object+0x42>
 94f:	e8 00 00 00 00       	call   954 <operator_UMINUS_fbgc_int_object+0x42>	950: R_X86_64_PLT32	__stack_chk_fail-0x4
 954:	48 83 c4 18          	add    rsp,0x18
 958:	c3                   	ret    

0000000000000959 <operator_any_fbgc_object>:


struct fbgc_object * operator_any_fbgc_object(struct fbgc_object * a,struct fbgc_object * b,fbgc_token fun_type, struct fbgc_object * result){
 959:	f3 0f 1e fa          	endbr64 
 95d:	41 55                	push   r13
 95f:	41 54                	push   r12
 961:	55                   	push   rbp
 962:	53                   	push   rbx
 963:	89 d3                	mov    ebx,edx
 965:	41 50                	push   r8
	fbgc_token obj_type = MAX(a->type,b->type);
 967:	8a 17                	mov    dl,BYTE PTR [rdi]
 969:	8a 06                	mov    al,BYTE PTR [rsi]
 96b:	38 d0                	cmp    al,dl
 96d:	0f 42 c2             	cmovb  eax,edx

	switch(obj_type){
 970:	3c 03                	cmp    al,0x3
 972:	74 0b                	je     97f <operator_any_fbgc_object+0x26>
 974:	83 e8 04             	sub    eax,0x4
 977:	3c 04                	cmp    al,0x4
 979:	77 39                	ja     9b4 <operator_any_fbgc_object+0x5b>
 97b:	31 c0                	xor    eax,eax
 97d:	eb 35                	jmp    9b4 <operator_any_fbgc_object+0x5b>
 97f:	48 89 f5             	mov    rbp,rsi
 982:	49 89 cd             	mov    r13,rcx
		case INT:{
			int a1 = convert_fbgc_object_to_int(a);	
			int b1 = convert_fbgc_object_to_int(b);
			//cprintf(111,"a1 %d, b1 %d\n",a1,b1);
			//int b1 = (b->type != LOGIC) ? cast_fbgc_object_as_int(b)->content:(int)(cast_fbgc_object_as_logic(b)->content);		
			struct fbgc_object * c = fbgc_INT_operators[fun_type](a1,b1,result);
 985:	0f b6 db             	movzx  ebx,bl
			int a1 = convert_fbgc_object_to_int(a);	
 988:	e8 00 00 00 00       	call   98d <operator_any_fbgc_object+0x34>	989: R_X86_64_PLT32	convert_fbgc_object_to_int-0x4
			int b1 = convert_fbgc_object_to_int(b);
 98d:	48 89 ef             	mov    rdi,rbp
			int a1 = convert_fbgc_object_to_int(a);	
 990:	41 89 c4             	mov    r12d,eax
			int b1 = convert_fbgc_object_to_int(b);
 993:	e8 00 00 00 00       	call   998 <operator_any_fbgc_object+0x3f>	994: R_X86_64_PLT32	convert_fbgc_object_to_int-0x4
			struct fbgc_object * c = fbgc_INT_operators[fun_type](a1,b1,result);
 998:	4c 89 ea             	mov    rdx,r13
 99b:	44 89 e7             	mov    edi,r12d
			int b1 = convert_fbgc_object_to_int(b);
 99e:	89 c6                	mov    esi,eax
			struct fbgc_object * c = fbgc_INT_operators[fun_type](a1,b1,result);
 9a0:	48 8d 05 00 00 00 00 	lea    rax,[rip+0x0]        # 9a7 <operator_any_fbgc_object+0x4e>	9a3: R_X86_64_PC32	fbgc_INT_operators-0x4
 9a7:	48 8b 04 d8          	mov    rax,QWORD PTR [rax+rbx*8]
		case STRING: return NULL;
		case MATRIX: return NULL;
		case TUPLE: return NULL;
	}

}
 9ab:	59                   	pop    rcx
 9ac:	5b                   	pop    rbx
 9ad:	5d                   	pop    rbp
 9ae:	41 5c                	pop    r12
 9b0:	41 5d                	pop    r13
			struct fbgc_object * c = fbgc_INT_operators[fun_type](a1,b1,result);
 9b2:	ff e0                	jmp    rax
}
 9b4:	5a                   	pop    rdx
 9b5:	5b                   	pop    rbx
 9b6:	5d                   	pop    rbp
 9b7:	41 5c                	pop    r12
 9b9:	41 5d                	pop    r13
 9bb:	c3                   	ret    

00000000000009bc <print_fbgc_int_object>:
	operator_UMINUS_fbgc_int_object,
};



void print_fbgc_int_object(struct fbgc_object * obj){
 9bc:	f3 0f 1e fa          	endbr64 
	cprintf(011,"%d",cast_fbgc_object_as_int(obj)->content);  
 9c0:	8b 57 09             	mov    edx,DWORD PTR [rdi+0x9]
 9c3:	48 8d 35 00 00 00 00 	lea    rsi,[rip+0x0]        # 9ca <print_fbgc_int_object+0xe>	9c6: R_X86_64_PC32	.LC1-0x4
 9ca:	bf 09 00 00 00       	mov    edi,0x9
 9cf:	31 c0                	xor    eax,eax
 9d1:	e9 00 00 00 00       	jmp    9d6 <free_fbgc_int_object>	9d2: R_X86_64_PLT32	cprintf-0x4

00000000000009d6 <free_fbgc_int_object>:
}

void free_fbgc_int_object(struct fbgc_object * obj){
 9d6:	f3 0f 1e fa          	endbr64 
	//   free(obj);
}
 9da:	c3                   	ret    
