==================[INPUT STRING]=================

{x = y ==== 12j 1.23j 12 1.2 }
==================[WHILE LOOP BEGIN]=================

rule_reader is called rule_ptr:\0 \b \0\1+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:x 
Check 0 for :[x] = y ==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [\]0 \x hd+
rule_reader is called rule_ptr:\0 \x hd+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:x 
Check 0 for :[x] = y ==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [l]\_ ld\_*
rule_reader is called rule_ptr:l\_ ld\_*
FLAG : {+:0 *:0 $:1}, PATTERN:l STR_MATCH:_
check char is called mobile:x 
Check 1 for :[x] = y ==== 12j 1.23j 12 1.2 
satisfied_rule_section :1 0
###[Satisfied rule section :l\_]###
rule_reader is called rule_ptr:ld\_*

***************************STAR okunuyor

FLAG : {+:0 *:1 $:1}, PATTERN:ld STR_MATCH:_
check char is called mobile:  
+$+$check ediyorum :0
Check 0 for :x[ ]= y ==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[TOKEN IS FOUND]=================

--------------------------------------------------
[x : WORD]
--------------------------------------------------



rule_reader is called rule_ptr:\0 \b \0\1+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:= 
Check 0 for :x [=] y ==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [\]0 \x hd+
rule_reader is called rule_ptr:\0 \x hd+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:= 
Check 0 for :x [=] y ==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [l]\_ ld\_*
rule_reader is called rule_ptr:l\_ ld\_*
FLAG : {+:0 *:0 $:1}, PATTERN:l STR_MATCH:_
check char is called mobile:= 
Check 0 for :x [=] y ==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [o]+
rule_reader is called rule_ptr:o+
FLAG : {+:1 *:0 $:0}, PATTERN:o STR_MATCH:
check char is called mobile:= 
Check 1 for :x [=] y ==== 12j 1.23j 12 1.2 
satisfied_rule_section :1 0
###[Satisfied rule section :o+]###
check char is called mobile:  
Check 0 for :x =[ ]y ==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[TOKEN IS FOUND]=================

--------------------------------------------------
[= : OP]
--------------------------------------------------



rule_reader is called rule_ptr:\0 \b \0\1+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:y 
Check 0 for :x = [y] ==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [\]0 \x hd+
rule_reader is called rule_ptr:\0 \x hd+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:y 
Check 0 for :x = [y] ==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [l]\_ ld\_*
rule_reader is called rule_ptr:l\_ ld\_*
FLAG : {+:0 *:0 $:1}, PATTERN:l STR_MATCH:_
check char is called mobile:y 
Check 1 for :x = [y] ==== 12j 1.23j 12 1.2 
satisfied_rule_section :1 0
###[Satisfied rule section :l\_]###
rule_reader is called rule_ptr:ld\_*

***************************STAR okunuyor

FLAG : {+:0 *:1 $:1}, PATTERN:ld STR_MATCH:_
check char is called mobile:  
+$+$check ediyorum :0
Check 0 for :x = y[ ]==== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[TOKEN IS FOUND]=================

--------------------------------------------------
[y : WORD]
--------------------------------------------------



rule_reader is called rule_ptr:\0 \b \0\1+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:= 
Check 0 for :x = y [=]=== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [\]0 \x hd+
rule_reader is called rule_ptr:\0 \x hd+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:= 
Check 0 for :x = y [=]=== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [l]\_ ld\_*
rule_reader is called rule_ptr:l\_ ld\_*
FLAG : {+:0 *:0 $:1}, PATTERN:l STR_MATCH:_
check char is called mobile:= 
Check 0 for :x = y [=]=== 12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [o]+
rule_reader is called rule_ptr:o+
FLAG : {+:1 *:0 $:0}, PATTERN:o STR_MATCH:
check char is called mobile:= 
Check 1 for :x = y [=]=== 12j 1.23j 12 1.2 
satisfied_rule_section :1 0
###[Satisfied rule section :o+]###
check char is called mobile:= 
Check 1 for :x = y =[=]== 12j 1.23j 12 1.2 
satisfied_rule_section :1 1
check char is called mobile:= 
Check 1 for :x = y ==[=]= 12j 1.23j 12 1.2 
satisfied_rule_section :1 1
check char is called mobile:= 
Check 1 for :x = y ===[=] 12j 1.23j 12 1.2 
satisfied_rule_section :1 1
check char is called mobile:  
Check 0 for :x = y ====[ ]12j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[TOKEN IS FOUND]=================

--------------------------------------------------
[==== : OP]
--------------------------------------------------



rule_reader is called rule_ptr:\0 \b \0\1+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:1 
Check 0 for :x = y ==== [1]2j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [\]0 \x hd+
rule_reader is called rule_ptr:\0 \x hd+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:1 
Check 0 for :x = y ==== [1]2j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [l]\_ ld\_*
rule_reader is called rule_ptr:l\_ ld\_*
FLAG : {+:0 *:0 $:1}, PATTERN:l STR_MATCH:_
check char is called mobile:1 
Check 0 for :x = y ==== [1]2j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [o]+
rule_reader is called rule_ptr:o+
FLAG : {+:1 *:0 $:0}, PATTERN:o STR_MATCH:
check char is called mobile:1 
Check 0 for :x = y ==== [1]2j 1.23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [[]0]
rule_reader is called rule_ptr:[0]
tablo acildi
FLAG : {+:0 *:0 $:0}, PATTERN: STR_MATCH:
check char is called mobile:1 

^^^^^^^^^^^^^^^^^^^^[read_rule_table]^^^^^^^^^^^^^^^^^^^^

size:3
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:1 
Inside for loop >> Check : 1
State >> 1
##Moving to state : 1
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:2 
Inside for loop >> Check : 1
State >> 1
##Moving to state : 1
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:j 
Inside for loop >> Check : 0
---------------------------------------
Inputs[1]:\.
rule_reader is called rule_ptr:\.
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:.
check char is called mobile:j 
Inside for loop >> Check : 0
---------------------------------------
Inputs[2]:\j
rule_reader is called rule_ptr:\j
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:j
check char is called mobile:j 
Inside for loop >> Check : 1
State >> 3
##Moving to state : 3
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:  
Inside for loop >> Check : 0
---------------------------------------
Inputs[1]:\.
rule_reader is called rule_ptr:\.
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:.
check char is called mobile:  
Inside for loop >> Check : 0
---------------------------------------
Inputs[2]:\j
rule_reader is called rule_ptr:\j
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:j
check char is called mobile:  
Inside for loop >> Check : 0
Ras Rule : 
Ras str :  1.23j 12 1.2 
Check 0 for :x = y ==== 12j[ ]1.23j 12 1.2 
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE:1
++++++++++[CHECK = 0 CASE]++++++++++

==================[TOKEN IS FOUND]=================

--------------------------------------------------
[12j : COMPLEX]
--------------------------------------------------



rule_reader is called rule_ptr:\0 \b \0\1+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:1 
Check 0 for :x = y ==== 12j [1].23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [\]0 \x hd+
rule_reader is called rule_ptr:\0 \x hd+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:1 
Check 0 for :x = y ==== 12j [1].23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [l]\_ ld\_*
rule_reader is called rule_ptr:l\_ ld\_*
FLAG : {+:0 *:0 $:1}, PATTERN:l STR_MATCH:_
check char is called mobile:1 
Check 0 for :x = y ==== 12j [1].23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [o]+
rule_reader is called rule_ptr:o+
FLAG : {+:1 *:0 $:0}, PATTERN:o STR_MATCH:
check char is called mobile:1 
Check 0 for :x = y ==== 12j [1].23j 12 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [[]0]
rule_reader is called rule_ptr:[0]
tablo acildi
FLAG : {+:0 *:0 $:0}, PATTERN: STR_MATCH:
check char is called mobile:1 

^^^^^^^^^^^^^^^^^^^^[read_rule_table]^^^^^^^^^^^^^^^^^^^^

size:3
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:1 
Inside for loop >> Check : 1
State >> 1
##Moving to state : 1
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:. 
Inside for loop >> Check : 0
---------------------------------------
Inputs[1]:\.
rule_reader is called rule_ptr:\.
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:.
check char is called mobile:. 
Inside for loop >> Check : 1
State >> 2
##Moving to state : 2
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:2 
Inside for loop >> Check : 1
State >> 2
##Moving to state : 2
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:3 
Inside for loop >> Check : 1
State >> 2
##Moving to state : 2
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:j 
Inside for loop >> Check : 0
---------------------------------------
Inputs[1]:\.
rule_reader is called rule_ptr:\.
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:.
check char is called mobile:j 
Inside for loop >> Check : 0
---------------------------------------
Inputs[2]:\j
rule_reader is called rule_ptr:\j
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:j
check char is called mobile:j 
Inside for loop >> Check : 1
State >> 3
##Moving to state : 3
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:  
Inside for loop >> Check : 0
---------------------------------------
Inputs[1]:\.
rule_reader is called rule_ptr:\.
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:.
check char is called mobile:  
Inside for loop >> Check : 0
---------------------------------------
Inputs[2]:\j
rule_reader is called rule_ptr:\j
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:j
check char is called mobile:  
Inside for loop >> Check : 0
Ras Rule : 
Ras str :  12 1.2 
Check 0 for :x = y ==== 12j 1.23j[ ]12 1.2 
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE:1
++++++++++[CHECK = 0 CASE]++++++++++

==================[TOKEN IS FOUND]=================

--------------------------------------------------
[1.23j : COMPLEX]
--------------------------------------------------



rule_reader is called rule_ptr:\0 \b \0\1+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:1 
Check 0 for :x = y ==== 12j 1.23j [1]2 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [\]0 \x hd+
rule_reader is called rule_ptr:\0 \x hd+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:1 
Check 0 for :x = y ==== 12j 1.23j [1]2 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [l]\_ ld\_*
rule_reader is called rule_ptr:l\_ ld\_*
FLAG : {+:0 *:0 $:1}, PATTERN:l STR_MATCH:_
check char is called mobile:1 
Check 0 for :x = y ==== 12j 1.23j [1]2 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [o]+
rule_reader is called rule_ptr:o+
FLAG : {+:1 *:0 $:0}, PATTERN:o STR_MATCH:
check char is called mobile:1 
Check 0 for :x = y ==== 12j 1.23j [1]2 1.2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [[]0]
rule_reader is called rule_ptr:[0]
tablo acildi
FLAG : {+:0 *:0 $:0}, PATTERN: STR_MATCH:
check char is called mobile:1 

^^^^^^^^^^^^^^^^^^^^[read_rule_table]^^^^^^^^^^^^^^^^^^^^

size:3
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:1 
Inside for loop >> Check : 1
State >> 1
##Moving to state : 1
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:2 
Inside for loop >> Check : 1
State >> 1
##Moving to state : 1
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:  
Inside for loop >> Check : 0
---------------------------------------
Inputs[1]:\.
rule_reader is called rule_ptr:\.
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:.
check char is called mobile:  
Inside for loop >> Check : 0
---------------------------------------
Inputs[2]:\j
rule_reader is called rule_ptr:\j
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:j
check char is called mobile:  
Inside for loop >> Check : 0
Ras Rule : 
Ras str :  1.2 
Check 0 for :x = y ==== 12j 1.23j 12[ ]1.2 
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE:1
++++++++++[CHECK = 0 CASE]++++++++++

==================[TOKEN IS FOUND]=================

--------------------------------------------------
[12 : INT]
--------------------------------------------------



rule_reader is called rule_ptr:\0 \b \0\1+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:1 
Check 0 for :x = y ==== 12j 1.23j 12 [1].2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [\]0 \x hd+
rule_reader is called rule_ptr:\0 \x hd+
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:0
check char is called mobile:1 
Check 0 for :x = y ==== 12j 1.23j 12 [1].2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [l]\_ ld\_*
rule_reader is called rule_ptr:l\_ ld\_*
FLAG : {+:0 *:0 $:1}, PATTERN:l STR_MATCH:_
check char is called mobile:1 
Check 0 for :x = y ==== 12j 1.23j 12 [1].2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [o]+
rule_reader is called rule_ptr:o+
FLAG : {+:1 *:0 $:0}, PATTERN:o STR_MATCH:
check char is called mobile:1 
Check 0 for :x = y ==== 12j 1.23j 12 [1].2 
++++++++++[CHECK = 0 CASE]++++++++++

==================[CHANGING the RULE]=================

Yeni rule : [[]0]
rule_reader is called rule_ptr:[0]
tablo acildi
FLAG : {+:0 *:0 $:0}, PATTERN: STR_MATCH:
check char is called mobile:1 

^^^^^^^^^^^^^^^^^^^^[read_rule_table]^^^^^^^^^^^^^^^^^^^^

size:3
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:1 
Inside for loop >> Check : 1
State >> 1
##Moving to state : 1
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:. 
Inside for loop >> Check : 0
---------------------------------------
Inputs[1]:\.
rule_reader is called rule_ptr:\.
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:.
check char is called mobile:. 
Inside for loop >> Check : 1
State >> 2
##Moving to state : 2
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:2 
Inside for loop >> Check : 1
State >> 2
##Moving to state : 2
---------------------------------------
Inputs[0]:d
rule_reader is called rule_ptr:d
FLAG : {+:0 *:0 $:0}, PATTERN:d STR_MATCH:
check char is called mobile:  
Inside for loop >> Check : 0
---------------------------------------
Inputs[1]:\.
rule_reader is called rule_ptr:\.
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:.
check char is called mobile:  
Inside for loop >> Check : 0
---------------------------------------
Inputs[2]:\j
rule_reader is called rule_ptr:\j
FLAG : {+:0 *:0 $:1}, PATTERN: STR_MATCH:j
check char is called mobile:  
Inside for loop >> Check : 0
Ras Rule : 
Ras str :  
Check 0 for :x = y ==== 12j 1.23j 12 1.2[ ]
EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE:1
++++++++++[CHECK = 0 CASE]++++++++++

==================[TOKEN IS FOUND]=================

--------------------------------------------------
[1.2 : DOUBLE]
--------------------------------------------------



[x : WORD]
[= : OP]
[y : WORD]
[==== : OP]
[12j : COMPLEX]
[1.23j : COMPLEX]
[12 : INT]
[1.2 : DOUBLE]
